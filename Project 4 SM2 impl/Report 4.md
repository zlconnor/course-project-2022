# 山东大学网络空间安全学院

# 网络空间安全创新创业实践

<img src="F:\typora_img\sdu.webp" alt="sdu" style="zoom: 25%;" />







# Project 4 SM2 impl

# 姓名：张麟康          

# 学号：201900301107





















## 原理分析

### ECC加密算法

#### 椭圆曲线离散对数问题（ECDLP）

椭圆曲线上的两个点$P$和$Q$，$k$为整数。
$$
Q=kP
$$
椭圆曲线加密的数学原理：点$P$称为基点；$k$为私钥；$Q$为公钥。

* 给定$k$和$P$，根据加法法则，计算$Q$很容易。
* 给定$P$和$Q$，求$k$非常困难。

椭圆曲线：$y^2=x^3+ax+b(4a^3+27b^2\neq 0)$**【描述方程与计算椭圆周长的方程类似】**

> 关于x轴对称，不存在奇点（处处有切线）。

<img src="F:\typora_img\image-20220722194608839.png" alt="image-20220722194608839" style="zoom:50%;" /><img src="F:\typora_img\image-20220722194621132.png" alt="image-20220722194621132" style="zoom:50%;" />

<img src="F:\typora_img\image-20220722194701821.png" alt="image-20220722194701821" style="zoom:50%;" /><img src="F:\typora_img\image-20220722194740312.png" alt="image-20220722194740312" style="zoom:50%;" />

#### ECC过程

1. 选一条椭圆曲线$Ep(a,b)$，并取椭圆曲线上一点作为**基点**$P$
2. 选择一个大数$k$作为**私钥**，并生成公钥$Q=kP$
3. 加密：选择**随机数$r$**，将消息$M$生成密文$C$，密文是一个点对即$C=(rP,M+rQ)$
4. 解密：$M+rQ-k(rP)=M+r(kP)-k(rP)=M$

椭圆曲线是连续的，并不适合加密，要将椭圆曲线变成离散的点，因此把椭圆曲线定义在**有限域**上。

> 如果域F只包含有限个元素则称其为有限域。
>
> 有限域中元素的个数称为有限域的阶。
>
> 每个有限域的阶必为素数的幂，即有限域的阶可表示为$p^n$
>
> 该有限域通常称为Galois域，记作$GF(p^n)$。
>
> 在域的定义上，作如下修改：
>
> 1. 定义模$p$加法和模$p$乘法
> 2. 集合内的元素经过加法和乘法计算结果仍在集合内==（封闭性）==
> 3. 计算符合==交换律、结合律、分配律==
> 4. 加法和乘法有==单位元==

有限域上的椭圆曲线运算：

<img src="F:\typora_img\image-20220722200112600.png" alt="image-20220722200112600" style="zoom: 67%;" /><img src="F:\typora_img\image-20220722200123290.png" alt="image-20220722200123290" style="zoom:67%;" />

<img src="F:\typora_img\image-20220722200130318.png" alt="image-20220722200130318" style="zoom:67%;" />

### SM2加密算法及流程

#### 加密算法

设需要发送的消息为比特串$M$，$klen$为M的比特长度。

1. 用随机数发生器产生随机数$k\in[1,n-1]$

2. 计算椭圆曲线点$C_1=[k]G=(x_1,y_1)$，将$C_1$的**数据类型转换为比特串**

3. 计算椭圆曲线点$S=[h]P_B$，若$S$是无穷远点则报错并退出

4. 计算椭圆曲线点$[k]P_B=(x_2,y_2)$并将其**数据类型转换为比特串**

5. 计算$t=KDF(x_2||y_2,klen)$【**密钥派生函数**】，若$t$为全0比特串则返回第一步

   > 密钥派生函数用于从一个共享的秘密比特串中派生出密钥数据。
   >
   > 在密钥协商过程中，密钥派生函数作用在密钥交换所获共享的秘密比特串上，从中产生所需的会话密钥或进一步加密所需的密钥数据。
   >
   > ![image-20220722202114529](F:\typora_img\image-20220722202114529.png)

6. 计算$C_2=M\oplus t$

7. 计算$C_3=Hash(x_2||M||y_2)$

8. 输出密文$C=C_1||C_2||C_3$

#### 解密算法

1. 从密文C中取出比特串$C_1$并将其转换为椭圆曲线上的点坐标
2. 计算椭圆曲线上的点$S=[h]PB$，判断$S$是否为无穷远点，若是则错误退出。
3. 计算$[dB]C_1=(x_2,y_2)$
4. 计算$t=KDF(x_2||y_2,klen)$，若$t$为全0比特串则错误退出
5. 从$C$中取出比特串$C_2$，计算$M'=C_2\oplus t$
6. 计算$u=Hash(x_2||M'||y_2)$，从$C$中取出比特串$C_3$，比较$u$和$C_3$，若$u$不等于$C_3$则错误退出
7. 得到明文$M'$

### 正确性验证

由于$[dB]C_1=[dB][k]G=[k]PB=(x_2,y_2)$，其中$PB=[dB]G$，易知$M'=M$。

因此，若$M=M'$则必有$u=C_3$，从而解密过程中的第6步用于验证解密是否成功。

## 具体实现

### 代码结构

本项目采用Python实现，哈希函数采用hashlib库中的sha256算法，项目主要包含两个文件即utils.py和sm2_new.py，其中utils.py中主要包含一些与SM2加密算法耦合度较低的工具类函数如计算哈希值、模逆运算等，而sm2_new.py文件中主要编写SM2类用来具体实现SM2算法的加密效果。

### SM2主体部分具体实现

首先编写SM2类，定义椭圆曲线的具体参数，其中size变量表示明文分组大小，v表示哈希函数的输出比特长度，h为余因子。

![image-20220722233809768](F:\typora_img\image-20220722233809768.png)

对于加密函数encrypt()，其参数为字符串形式的明文和椭圆曲线点形式公钥，返回十六进制字符串形式的明文。

首先将明文编码，按照分组大小进行分组，构建明文分块列表，最后一个分块不足一整个分块时候作为单个分块处理。

![image-20220722234053089](F:\typora_img\image-20220722234053089.png)

接下来调用块加密函数encrypt_block()，干函数首先将分块转换为二进制串形式并补足为8的整数倍比特长，随后根据公钥，进入循环。

1. 用随机数发生器产生随机数$k\in[1,n-1]$

   ![image-20220722234243235](F:\typora_img\image-20220722234243235.png)

2. 计算椭圆曲线点$C_1=[k]G=(x_1,y_1)$，将$C_1$的**数据类型转换为比特串**

   ![image-20220722234257019](F:\typora_img\image-20220722234257019.png)

3. 计算椭圆曲线点$S=[h]P_B$，若$S$是无穷远点则报错并退出

   ![image-20220722235430921](F:\typora_img\image-20220722235430921.png)

4. 计算椭圆曲线点$[k]P_B=(x_2,y_2)$并将其**数据类型转换为比特串**

   ![image-20220722234321821](F:\typora_img\image-20220722234321821.png)

5. 计算$t=KDF(x_2||y_2,klen)$【**密钥派生函数**】，若$t$为全0比特串则返回第一步

   ![image-20220722234337874](F:\typora_img\image-20220722234337874.png)

   > KDF按如下方案编写：
   >
   > ![image-20220722202114529](F:\typora_img\image-20220722202114529.png)
   >
   > ![image-20220722234430040](F:\typora_img\image-20220722234430040.png)

6. 计算$C_2=M\oplus t$

   ![image-20220722234508363](F:\typora_img\image-20220722234508363.png)

7. 计算$C_3=Hash(x_2||M||y_2)$

   ![image-20220722234521814](F:\typora_img\image-20220722234521814.png)

8. 输出密文$C=C_1||C_2||C_3$

   ![image-20220722234540602](F:\typora_img\image-20220722234540602.png)

对于解密函数decrypt()，其参数为十六进制字符串形式的密文和私钥，返回明文字符串。

首先将密文划分为若干个密文分组。

![image-20220722234653170](F:\typora_img\image-20220722234653170.png)

接下来对于每个密文分组调用块解密函数decrypt_block()对每个块进行单独解密。

1. 从密文C中取出比特串$C_1$并将其转换为椭圆曲线上的点坐标

   ![image-20220722234749701](F:\typora_img\image-20220722234749701.png)

2. 计算椭圆曲线上的点$S=[h]PB$，判断$S$是否为无穷远点，若是则错误退出。

   ![image-20220722235418502](F:\typora_img\image-20220722235418502.png)

3. 计算$[dB]C_1=(x_2,y_2)$

   ![image-20220722234814788](F:\typora_img\image-20220722234814788.png)

4. 计算$t=KDF(x_2||y_2,klen)$，若$t$为全0比特串则错误退出

   ![image-20220722234825279](F:\typora_img\image-20220722234825279.png)

5. 从$C$中取出比特串$C_2$，计算$M'=C_2\oplus t$

   ![image-20220722234836328](F:\typora_img\image-20220722234836328.png)

6. 计算$u=Hash(x_2||M'||y_2)$，从$C$中取出比特串$C_3$，比较$u$和$C_3$，若$u$不等于$C_3$则错误退出

   ![image-20220722234845652](F:\typora_img\image-20220722234845652.png)

7. 得到明文$M'$

#### SM2椭圆曲线运算实现

根据有限域上椭圆曲线上点的运算法则，设计如下函数。

1. 两个相同点相加

   ![image-20220722234954011](F:\typora_img\image-20220722234954011.png)

2. 两个不同点相加

   ![image-20220722235008656](F:\typora_img\image-20220722235008656.png)

3. 相邻的两个点相加

   ![image-20220722235024226](F:\typora_img\image-20220722235024226.png)

4. 倍点

   ![image-20220722235052323](F:\typora_img\image-20220722235052323.png)

## 运行结果

通过多次测试可以看到成功实现SM2算法的基本功能。

![image-20220722235515704](F:\typora_img\image-20220722235515704.png)![image-20220722235650327](F:\typora_img\image-20220722235650327.png)

![image-20220722235725527](F:\typora_img\image-20220722235725527.png)
